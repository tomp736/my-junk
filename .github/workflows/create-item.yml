name: On Issue - Create Item

on:
  issues:
    types: [opened, edited]

jobs:
  create-item-pr:
    if: contains(toJSON(github.event.issue.labels.*.name), 'new-item')
    runs-on: ubuntu-latest

    steps:
      - name: Generate GitHub App Token
        id: generate-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.GH_APP_AUTOMATION_APP_ID }}
          private-key: ${{ secrets.GH_APP_AUTOMATION_APP_PRIVATE_KEY }}

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ steps.generate-token.outputs.token }}

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Parse issue and create JSON
        id: create-json
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // Parse issue body to extract form data
            const issueBody = context.payload.issue.body;

            // Function to extract field value from issue body
            function extractField(body, fieldName) {
              const regex = new RegExp(`### ${fieldName}\\s*\\n\\s*(.+?)(?=\\n###|\\n\\n###|$)`, 's');
              const match = body.match(regex);
              return match ? match[1].trim() : '';
            }

            // Extract all fields
            const itemId = extractField(issueBody, 'Item ID');
            const titleEn = extractField(issueBody, 'Item Title \\(English\\)');
            const titlePl = extractField(issueBody, 'Item Title \\(Polish\\)');
            const descriptionEn = extractField(issueBody, 'Description \\(English\\)');
            const descriptionPl = extractField(issueBody, 'Description \\(Polish\\)');
            const price = parseFloat(extractField(issueBody, 'Price'));
            const currency = extractField(issueBody, 'Currency');
            const condition = extractField(issueBody, 'Condition');
            const category = extractField(issueBody, 'Category');
            const location = extractField(issueBody, 'Location');
            const imagesText = extractField(issueBody, 'Images');
            const tagsText = extractField(issueBody, 'Tags');

            // Validate required fields
            if (!itemId || !titleEn || !titlePl || !descriptionEn || !descriptionPl || !price || !currency) {
              throw new Error('Missing required fields');
            }

            // Extract image URLs from issue body
            const imageUrls = [];

            // Get URLs from the Image URLs field
            if (imagesText) {
              const urlsFromField = imagesText
                .split('\n')
                .map(line => line.trim())
                .filter(line => line && line.startsWith('http'));
              imageUrls.push(...urlsFromField);
            }

            // Also check for images embedded in the issue body (GitHub uploads)
            const embeddedImages = issueBody.match(/!\[.*?\]\((https?:\/\/[^\)]+)\)/g);
            if (embeddedImages) {
              embeddedImages.forEach(md => {
                const urlMatch = md.match(/\((https?:\/\/[^\)]+)\)/);
                if (urlMatch && !imageUrls.includes(urlMatch[1])) {
                  imageUrls.push(urlMatch[1]);
                }
              });
            }

            console.log(`Found ${imageUrls.length} image URLs to download`);

            // Download images and save locally
            const downloadedImages = [];
            const imagesDir = 'images';

            if (!fs.existsSync(imagesDir)) {
              fs.mkdirSync(imagesDir, { recursive: true });
            }

            for (let i = 0; i < imageUrls.length; i++) {
              const url = imageUrls[i];
              try {
                console.log(`Downloading image ${i + 1}/${imageUrls.length}: ${url}`);

                const response = await fetch(url);
                if (!response.ok) {
                  console.warn(`Failed to download ${url}: ${response.status}`);
                  continue;
                }

                // Get file extension from URL or content-type
                let ext = 'jpg';
                const urlExt = url.split('.').pop().split('?')[0].toLowerCase();
                if (['jpg', 'jpeg', 'png', 'gif', 'webp'].includes(urlExt)) {
                  ext = urlExt;
                } else {
                  const contentType = response.headers.get('content-type');
                  if (contentType?.includes('png')) ext = 'png';
                  else if (contentType?.includes('gif')) ext = 'gif';
                  else if (contentType?.includes('webp')) ext = 'webp';
                }

                // Create filename: itemId-index.ext
                const filename = `${itemId}-${i + 1}.${ext}`;
                const filepath = `${imagesDir}/${filename}`;

                // Download and save
                const buffer = await response.arrayBuffer();
                fs.writeFileSync(filepath, Buffer.from(buffer));

                downloadedImages.push(filepath);
                console.log(`‚úì Saved: ${filepath}`);
              } catch (error) {
                console.warn(`Failed to download image ${url}: ${error.message}`);
              }
            }

            // Process tags
            const tags = tagsText
              .split(',')
              .map(tag => tag.trim())
              .filter(tag => tag);

            // Create item object
            const item = {
              id: itemId,
              title: {
                en: titleEn,
                pl: titlePl
              },
              description: {
                en: descriptionEn,
                pl: descriptionPl
              },
              price: price,
              currency: currency,
              condition: condition.toLowerCase(),
              category: category,
              status: "available",
              images: downloadedImages,
              datePosted: new Date().toISOString(),
              location: location,
              tags: tags
            };

            // Create items directory if it doesn't exist
            const itemsDir = 'items';
            if (!fs.existsSync(itemsDir)) {
              fs.mkdirSync(itemsDir, { recursive: true });
            }

            // Write JSON file
            const filename = `${itemsDir}/${itemId}.json`;
            fs.writeFileSync(filename, JSON.stringify(item, null, 2) + '\n');

            console.log(`Created item file: ${filename}`);
            console.log(`Downloaded ${downloadedImages.length} images`);

            // Return item data for use in next steps
            core.setOutput('filename', filename);
            core.setOutput('itemId', itemId);
            core.setOutput('titleEn', titleEn);
            core.setOutput('titlePl', titlePl);
            core.setOutput('imageCount', downloadedImages.length.toString());

            return {
              filename: filename,
              itemId: itemId,
              titleEn: titleEn,
              titlePl: titlePl,
              imageCount: downloadedImages.length
            };

      - name: Create Pull Request
        id: create-pr
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ steps.generate-token.outputs.token }}
          commit-message: |
            Add item: ${{ steps.create-json.outputs.titleEn }}

            - Item ID: ${{ steps.create-json.outputs.itemId }}
            - English: ${{ steps.create-json.outputs.titleEn }}
            - Polish: ${{ steps.create-json.outputs.titlePl }}
            - Images: ${{ steps.create-json.outputs.imageCount }} downloaded

            Closes #${{ github.event.issue.number }}
          branch: item-${{ steps.create-json.outputs.itemId }}-issue-${{ github.event.issue.number }}
          delete-branch: true
          title: "Add item: ${{ steps.create-json.outputs.titleEn }}"
          body: |
            ## New Item Submission

            This PR adds a new item from issue #${{ github.event.issue.number }}

            **Item ID:** `${{ steps.create-json.outputs.itemId }}`
            **Title (EN):** ${{ steps.create-json.outputs.titleEn }}
            **Title (PL):** ${{ steps.create-json.outputs.titlePl }}
            **Images Downloaded:** ${{ steps.create-json.outputs.imageCount }}

            ### Changes
            - Added `items/${{ steps.create-json.outputs.itemId }}.json`
            - Downloaded ${{ steps.create-json.outputs.imageCount }} image(s) to `images/` directory

            ### Review Checklist
            - [ ] Item information is accurate
            - [ ] Both English and Polish translations are correct
            - [ ] Price and currency are correct
            - [ ] Images are properly referenced

            Closes #${{ github.event.issue.number }}
          labels: new-item
          assignees: ${{ github.repository_owner }}
          committer: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>
          author: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>

      - name: Comment on issue
        if: steps.create-pr.outputs.pull-request-number
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.generate-token.outputs.token }}
          script: |
            const prNumber = '${{ steps.create-pr.outputs.pull-request-number }}';
            const prUrl = '${{ steps.create-pr.outputs.pull-request-url }}';

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `‚úÖ **Pull Request Created!**

            A pull request has been automatically created for your item submission.

            üîó **PR:** #${prNumber}
            üîó **URL:** ${prUrl}

            The item will be added to the repository once the PR is reviewed and merged.

            Thank you for your submission!`
            });

      - name: Add processed label
        if: steps.create-pr.outputs.pull-request-number
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.generate-token.outputs.token }}
          script: |
            // Add 'processed' label
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: ['processed']
            });

      - name: Handle errors
        if: failure()
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.generate-token.outputs.token }}
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `‚ùå **Error**

            There was an error processing this item. Please check that:

            - All required fields are filled out correctly
            - The Item ID is unique
            - Price is a valid number
            - All fields contain valid data

            Please edit the issue and try again.`
            });
